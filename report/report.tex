\section{Introduction}
  
  Generally, robustness in systems is defined as an ability to operate under various circumstances and handle a wide range of expected and unexpected inputs. Though, definition of robustness changes depending on environment and existing requirements within it. We will consider robustness in the context of tools, software applications and operating systems. These systems, usually, differ in their responsibilities and functional and non-functional requirements and must provide different qualities of robustness. Robustness in these environments is achieved using well known tools and technologies such as programming languages, design patterns, recommended good practices and others. It's worth mentioning that robustness has to be one of the fundamental properties when designing a system and is not something that can be added at a later software development stage.

  In addition, system testing can and should be done to ensure that our system supports a required level of robustness. Its an important step in software engineering and development cycle, which somewhat proves integrity and rightness of separate software components, as well as, the whole system.


\section{Programming Languages}

%First rule for robust systems: all rules inside the system must work. 
  Most programming languages are built with some paradigms, e.g. Object Oriented Programming languages (OOP) have encapsulation, inheritance, polymorphism. In most OOP languages these rules are followed closely, with some exceptions where they are violated: C++ friend functions, which directly violates the encapsulation principle. Or, for example, dynamic typing in javascript, which exhibits a peculiar functionality: $[]+\{\}$ (array concatenation with an object results into an object), but $\{\}+[]$ (object concatenation with an array results into 0 (integer zero))\cite{hagen2007architectural}.

  Language can be called robust only if all compiled/interpreted code transferred without any internal errors. Language is middle ware between code and program. Robust language should prevent any kind of possible problems while translating code to machine code. Such mistake can result in non properly functioning program in practice, but working code in theory. This is why language should provide notifications/warning/errors about code validity.

  Robust language can't exist without tools for detecting exceptions (try/catch) and preventing program to terminate, if some critical issue was encountered. Best example of how a programming language can fail is definitely a null pointer exception, in contrast Objective-C has no such kind of errors at all - it is acceptable to send message to nil object.

  Finally, a robust language should have a support for older versions of language and a mechanism of maintenance of depreciations. A good example is Java, SE 7, which is strongly compatible with previous Java platform versions. Almost all existing Java programs should run on Java SE 7 without modification. However, there are some  potential source and binary incompatibilities in the JRE and JDK that involve rare circumstances and "corner cases" that are documented here for completeness.\cite{huhns2002robust}

\section{Operating Systems}
  There are a large number of different operating systems and all these systems have various non-functional requirements. The non-functional requirements are tightly linked to the type of environment, the operating system should be able to operate in. This section will focus on a few examples of different types of operating systems and their non-functional requirements.

  \subsection{Real-time system}
    Real-time systems are systems, which are subjected to a real-time constraint. A real-time constraint is often understood to be a deadline, in the order of milliseconds or microseconds. The most common scenario is that, a real-time system must guarantee to finish a process execution before a given deadline. But, this is not necessarily the only case, there are also examples, where a process needs to be finished after a certain time constraint.
  
  \subsection{Layered Architecture}
    There is a whole field within operating system architecture, but this is outside the scope of this paragraph. Here the focus will be on the layered architecture from a robustness angle. The aim of the layered architecture approach is, to make sure that operating system is reliable and secure. The idea is that in contrast to a monolithic kernel, the layered architecture moves as much code outside the kernel and by doing this making the kernel more transparent and reliable. The fewer lines of code a developer has to maintain, the fewer errors there should be in the code. By separating, the code blocks into smaller entities, the overall system should be able to handle failure better. An example could be that if the print service fails, this should not crash the system. This is because, the print service is not the same as the kernel. This would leave the system operating running, but without the ability to print a page.
  \subsection{Embedded System}
    Embedded systems can in many ways be compared to both a real-time system and a layered architecture. The embedded systems is usually very restricted in terms of the resources it can consume and it usually also has a certain real-time constraint attached to it. Example of an  embedded system can be the bank kiosk. In the kiosk, the operating system architecture has to be optimized to be as responsive as possible, otherwise the customers would grow impatient while waiting for the system to respond. In order for the operating system to be responsive, it must be structured and efficient. 

\section{Application of Robust Software Systems}
  In today's society there are many systems which need to be robust and can't afford to crash. This ranges from large critical systems such as those deployed in hospitals, to smaller critical systems such as pacemakers.

  When building robust software, one can simply not add more code to achieve robustness.  Adding code blindly to software systems like this, will not achieve robustness â€“ conversely it adds unnecessary complexity and makes the system harder to analyze and understand in general. However, as argued by Huhns \& Holderfield \cite{huhns2002robust}, adding more code can in fact make software better but only if it is added in the right way.

  Redundancy is an important concept when discussing robust software systems. Redundancy, in this context refers to having duplications of critical components or functions of a given system. Hence, if one component fails then there is another which can take over. However, adding identical duplications doesn't get you very far as the duplication is likely to reproduce the error failing the initial component. Therefore, redundancy aims to provide components which provide the same functionality, which is achieved in a different way.  This is apparent in many software systems which claim to be robust.

  One example could be that of a web-based shop. Typically, this is the main income stream for the company, and if there is some fault, say a faulty front end, then this has catastrophic consequences for the company's survival as clients cannot purchase products/services from the web shop.

  So, in terms of robustness as a whole, we focus on how some computer systems run and how it copes with errors. One can say that the harder it is to provoke an error from a system, the more robust the system is. Self-evidently, robustness is a property that most applications strive to have. It's seldom to see a successful application, which has many errors or one which fails frequently.

  Ensuring that a system is robust is no trivial task, there are a lot of parameters that must be taken into consideration both when designing, implementing and testing a system that is meant to be robust. 

  Using formal methods of mathematics, one can attempt to prove (or disprove) the correctness of algorithms underlying a certain system with respect to a certain formal specification or property. This can be helpful in determining the correctness of certain parts of a given system and is a step in the right direction for ensuring robustness.