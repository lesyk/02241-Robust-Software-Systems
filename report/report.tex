\section{Introduction}
  
  Generally, robustness in systems is defined as an ability to operate under various circumstances and handle a wide range of expected and unexpected inputs. Though, definition of robustness changes depending on environment and existing requirements within it. We will consider robustness in the context of tools, software applications and operating systems. These systems, usually, differ in their responsibilities and functional and non-functional requirements and must provide different qualities of robustness. Robustness in these environments is achieved using well known tools and technologies such as programming languages, design patterns, recommended good practices and others. It's worth mentioning that robustness has to be one of the fundamental properties when designing a system and is not something that can be added at a later software development stage.

  In addition, system testing can and should be done to ensure that our system supports a required level of robustness. Its an important step in software engineering and development cycle, which somewhat proves integrity and rightness of separate software components, as well as, the whole system.


\subsection{Programming Languages}

%First rule for robust systems: all rules inside the system must work. 
  Most programming languages are built with some paradigms, e.g. Object Oriented Programming languages (OOP) have encapsulation, inheritance, polymorphism. In most OOP languages these rules are followed closely, with some exceptions where they are violated: C++ friend functions, which directly violates the encapsulation principle. Or, for example, dynamic typing in javascript, which exhibits a peculiar functionality: $[]+\{\}$ (array concatenation with an object results into an object), but $\{\}+[]$ (object concatenation with an array results into 0 (integer zero))\cite{hagen2007architectural}.

  Language can be called robust only if all compiled/interpreted code transferred without any internal errors. Language is middle ware between code and program. Robust language should prevent any kind of possible problems while translating code to machine code. Such mistake can result in non properly functioning program in practice, but working code in theory. This is why language should provide notifications/warning/errors about code validity.

  Robust language can't exist without tools for detecting exceptions (try/catch) and preventing program to terminate, if some critical issue was encountered. Best example of how a programming language can fail is definitely a null pointer exception, in contrast Objective-C has no such kind of errors at all - it is acceptable to send message to nil object.

  Finally, a robust language should have a support for older versions of language and a mechanism of maintenance of depreciations. A good example is Java, SE 7, which is strongly compatible with previous Java platform versions. Almost all existing Java programs should run on Java SE 7 without modification. However, there are some  potential source and binary incompatibilities in the JRE and JDK that involve rare circumstances and "corner cases" that are documented here for completeness.\cite{huhns2002robust}

\subsection{Operating Systems}
  There are a large number of different operating systems and all these systems have various non-functional requirements. The non-functional requirements are tightly linked to the type of environment, the operating system should be able to operate in. This section will focus on a few examples of different types of operating systems and their non-functional requirements.

  \subsubsection{Real-time system}
    Real-time systems are systems, which are subjected to a real-time constraint. A real-time constraint is often understood to be a deadline, in the order of milliseconds or microseconds. The most common scenario is that, a real-time system must guarantee to finish a process execution before a given deadline. But, this is not necessarily the only case, there are also examples, where a process needs to be finished after a certain time constraint.
  
  \subsubsection{Layered Architecture}
    There is a whole field within operating system architecture, but this is outside the scope of this paragraph. Here the focus will be on the layered architecture from a robustness angle. The aim of the layered architecture approach is, to make sure that operating system is reliable and secure. The idea is that in contrast to a monolithic kernel, the layered architecture moves as much code outside the kernel and by doing this making the kernel more transparent and reliable. The fewer lines of code a developer has to maintain, the fewer errors there should be in the code. By separating, the code blocks into smaller entities, the overall system should be able to handle failure better. An example could be that if the print service fails, this should not crash the system. This is because, the print service is not the same as the kernel. This would leave the system operating running, but without the ability to print a page.
  \subsubsection{Embedded System}
    Embedded systems can in many ways be compared to both a real-time system and a layered architecture. The embedded systems is usually very restricted in terms of the resources it can consume and it usually also has a certain real-time constraint attached to it. Example of an  embedded system can be the bank kiosk. In the kiosk, the operating system architecture has to be optimized to be as responsive as possible, otherwise the customers would grow impatient while waiting for the system to respond. In order for the operating system to be responsive, it must be structured and efficient. 

\subsection{Application of Robust Software Systems}

  In today's society there are many systems which need to be robust and can't afford to crash. This ranges from large critical systems such as those deployed in hospitals, to smaller critical systems such as pacemakers.

  When building robust software, one can simply not add more code to achieve robustness.  Adding code blindly to software systems like this, will not achieve robustness – conversely it adds unnecessary complexity and makes the system harder to analyze and understand in general. However, as argued by Huhns \& Holderfield \cite{huhns2002robust}, adding more code can in fact make software better but only if it is added in the right way.

  Redundancy is an important concept when discussing robust software systems. Redundancy, in this context refers to having duplications of critical components or functions of a given system. Hence, if one component fails then there is another which can take over. However, adding identical duplications doesn't get you very far as the duplication is likely to reproduce the error failing the initial component. Therefore, redundancy aims to provide components which provide the same functionality, which is achieved in a different way.  This is apparent in many software systems which claim to be robust.

  One example could be that of a web-based shop. Typically, this is the main income stream for the company, and if there is some fault, say a faulty front end, then this has catastrophic consequences for the company's survival as clients cannot purchase products/services from the web shop.

  So, in terms of robustness as a whole, we focus on how some computer systems run and how it copes with errors. One can say that the harder it is to provoke an error from a system, the more robust the system is. Self-evidently, robustness is a property that most applications strive to have. It's seldom to see a successful application, which has many errors or one which fails frequently.

  Ensuring that a system is robust is no trivial task, there are a lot of parameters that must be taken into consideration both when designing, implementing and testing a system that is meant to be robust. 

  Using formal methods of mathematics, one can attempt to prove (or disprove) the correctness of algorithms underlying a certain system with respect to a certain formal specification or property. This can be helpful in determining the correctness of certain parts of a given system and is a step in the right direction for ensuring robustness.
  
\section{Project Description}

  \subsection{Project objective}
    A goal of this project is to develop a robust analysis framework, which will be used as a tool to perform a static analysis on Java source code. In our development process we will address measured robustness properties so that it reflects in our project source code. It can be seen as bootstrapping of our own code quality, when our developed tool is used on its source code.

  \section{Robustness properties to be measured}
    We will target specific robustness properties such as code transparency, readability, maintainability and simplicity. To address these properties our tool will measure following code properties:
      \begin{itemize}
	\item \emph{Cyclomatic complexity.} Measure cyclomatic complexity of single code blocks and identify methods that should be refactored for simplicity and readability
	\item \emph{Code duplication.} Identify similar blocks of code that could be generalized
	\item \emph{Lines of codes and their growth over time.} Perform an analysis on growth of code lines over time, which could show progress of project. Such information could be extracted from source code version control system.
	\item \emph{Analyze package/module/variable naming against proposed scheme.} Check if developers are following required naming schemes possibly identifying "smelly" code.
	\item \emph{Unit dependencies.} Measure single unit's dependency count on other units. Identify units with too many dependencies, which should be refactored.
      \end{itemize}

  \subsection{Robustness properties to achieve in our code}
    For the development of this project we will employ Java development kit. As stated before we will consider source code properties that we are measuring for and it will reflect in our source code. Furthermore to improve robustness of our tool we will utilize a design by contract technique, which we will achieve using OVal library. Also we will deploy Unit testing to test our methods and modules.

\section{Analysis}

  \subsection{Cyclomatic complexity}
    \emph{Scope}: count the cyclomatic complexity of a Java Source file. \emph{Outside scope}: the cyclomatic complexity of Java Bytecode is not considered.
    
    \subsubsection{Background}
      The Cyclomatic Complexity is a software matic developed by Thomas J. McCabe and it is used to measure the complexity of a software application. 
    \subsubsection{Approach}
      An approach to measure the complexity in Java Source Code is define in Method Cyclomatic Complexity.
    \subsubsection{Dependencies}
      To measure the complexity, I need a source parser, such that I can count the different complexity indicators. 

  \subsection{Code duplication}
    For this kind of check we will use already implemented solution: Simian (Similarity Analyser) \cite{simian1}. It have all kind of possible scans of code on duplications and API \cite{simian2} for using it. In case of failure to work with it posible solution is using Rabin–Karp algorithm \cite{rabinkarp}.

  \subsection{Lines of codes and their growth over time}
    Perform an analysis on growth of code lines over time, which could show progress of project. Such information could be extracted from source code version control system.
    
    We will use by default git as source of getting how code have changed, also add ability for smooth adding of other source code management systems (svn, mercurial). For getting git we need JavaGit \cite{javagit}. Based on data from git we will give statistics how code have grown.

  \subsection{Analyze package/module/variable naming against proposed scheme}
    Check if developers are writing code that adheres to coding standards. Avoids typical code “smells”. Using static program analysers such as checkstyle \cite{checkstyle} one can perform checks on the program and alert the programmers of code that needs to be changed/refactored if it doesn’t match the proposed coding standards. It’s possible to extend Checkstyle by writing checks, filters and listeners. This allows Checkstyle to be customised extensively. 

    The idea here is to use Checkstyle as a base for checking against well known coding standards and then extend it where necessary to incorporate other robustness criteria that are relevant. 

    The end result of this feature will thus check a program statically to implicitly add to the robustness of the program by forcing the programmer to adhere to the standards.

  \subsection{Unit dependencies}
    For finding inner unit dependencies it is necessary to extract all declarations and uses of other types of units. As a possible solution Abstract Syntax Tree (AST) could be used to extract needed information from all compilation units. There are many tools to build an AST of Java code, though because we are focusing on Eclipse development environment we will employ Eclipse Java parser.

    Unit Dependency measurer will count occurrences of different type of Units that the Unit in question depends on. These measurements can be displayed in a matrix, which could visualize a degree of dependence of every Unit on the rest of Units. Furthermore, this tool will try to identify circular dependencies, where Unit A depends on Unit B which might depend on Unit A directly or indirectly through other dependencies.

\section{Preliminar Design}
  Our implementation of the components explained above will take the form of an Eclipse plug-in. This plug-in will then be able to perform checks on the program being inspected in order to find places in the code that does not adhere to the robustness properties that will be defined. 

  In terms of the design of our solution, we are planning to have a common “view” for the plug-in as an interface to the user. All the components will then be logically split into subparts/submodules, where each part represent a separate functionality from the others e.g. code duplication vs. naming conventions. These parts can then each run against the input and the result be gathered and shown to the user.